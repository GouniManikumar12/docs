---
title: "Weave Ad Format"
description: "Complete end-to-end guide for integrating AdMesh recommendations into your AI or LLM responses"
---

# Weave Ad Format - Complete Integration Guide

The **Weave Ad Format** is an API-based integration that gives you full control over how and where AdMesh recommendations appear in your AI-generated responses.

This guide walks you through the complete integration flow: creating sessions, fetching recommendations, formatting for your LLM, firing exposure pixels, and closing sessions.

---

## Integration Overview

```
1. Create Session
   ↓
2. Get Recommendations
   ↓
3. Format for LLM
   ↓
4. LLM Generates Response with [Product](link)[Ad]
   ↓
5. Fire Exposure Pixels
   ↓
6. Close Session (Optional)
```

---

## Step 1: Create Session

Each conversation or search thread starts with a **new AdMesh session**.
A session ensures all exposures, clicks, and conversions are tied together.

### When to Create

- When a user starts a new chat or query
- When a previous session expires (401)
- When the platform resets its context

<Tabs>
  <Tab title="TypeScript/JavaScript">
    ```typescript
    const ADMESH_BASE = "https://api.useadmesh.com";

    export async function createAdmeshSession() {
      try {
        const res = await fetch(`${ADMESH_BASE}/agent/session/new`, { method: "POST" });
        if (!res.ok) throw new Error("Failed to create AdMesh session");

        const { session_id } = await res.json();
        localStorage.setItem("admesh_session_id", session_id);
        console.log("✅ Session created:", session_id);
        return session_id;
      } catch (err) {
        console.error("⚠️ Session creation failed:", err);
        return `admesh_temp_${Date.now()}`;
      }
    }
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    import { useState, useCallback } from 'react';

    export function useAdmeshSession() {
      const [sessionId, setSessionId] = useState<string | null>(null);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const createSession = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
          const res = await fetch("https://api.useadmesh.com/agent/session/new", {
            method: "POST",
          });
          if (!res.ok) throw new Error("Failed to create session");

          const { session_id } = await res.json();
          setSessionId(session_id);
          localStorage.setItem("admesh_session_id", session_id);
          console.log("✅ Session created:", session_id);
          return session_id;
        } catch (err) {
          const message = err instanceof Error ? err.message : "Unknown error";
          setError(message);
          console.error("⚠️ Session creation failed:", message);
          return null;
        } finally {
          setLoading(false);
        }
      }, []);

      return { sessionId, loading, error, createSession };
    }
    ```
  </Tab>

  <Tab title="Android (Kotlin)">
    ```kotlin
    import kotlinx.coroutines.*
    import java.net.URL
    import java.net.HttpURLConnection

    class AdmeshSessionManager {
        companion object {
            private const val ADMESH_BASE = "https://api.useadmesh.com"
        }

        suspend fun createSession(): String? = withContext(Dispatchers.IO) {
            try {
                val url = URL("$ADMESH_BASE/agent/session/new")
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")

                if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val sessionId = extractSessionId(response)
                    android.util.Log.d("AdMesh", "✅ Session created: $sessionId")
                    sessionId
                } else {
                    android.util.Log.e("AdMesh", "⚠️ Failed to create session: ${connection.responseCode}")
                    null
                }
            } catch (e: Exception) {
                android.util.Log.e("AdMesh", "⚠️ Session creation failed: ${e.message}")
                null
            }
        }

        private fun extractSessionId(json: String): String {
            val regex = """"session_id"\s*:\s*"([^"]+)"""".toRegex()
            return regex.find(json)?.groupValues?.get(1) ?: ""
        }
    }
    ```
  </Tab>

  <Tab title="Flutter (Dart)">
    ```dart
    import 'package:http/http.dart' as http;
    import 'dart:convert';

    class AdmeshSessionManager {
      static const String admeshBase = 'https://api.useadmesh.com';

      static Future<String?> createSession() async {
        try {
          final response = await http.post(
            Uri.parse('$admeshBase/agent/session/new'),
            headers: {'Content-Type': 'application/json'},
          );

          if (response.statusCode == 200) {
            final data = jsonDecode(response.body);
            final sessionId = data['session_id'] as String;
            print('✅ Session created: $sessionId');
            return sessionId;
          } else {
            print('⚠️ Failed to create session: ${response.statusCode}');
            return null;
          }
        } catch (e) {
          print('⚠️ Session creation failed: $e');
          return null;
        }
      }
    }
    ```
  </Tab>

  <Tab title="Swift/iOS">
    ```swift
    import Foundation

    class AdmeshSessionManager {
        static let admeshBase = "https://api.useadmesh.com"

        static func createSession(completion: @escaping (String?) -> Void) {
            let url = URL(string: "\(admeshBase)/agent/session/new")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            URLSession.shared.dataTask(with: request) { data, response, error in
                guard let data = data, error == nil else {
                    print("⚠️ Session creation failed: \(error?.localizedDescription ?? "Unknown error")")
                    completion(nil)
                    return
                }

                do {
                    if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let sessionId = json["session_id"] as? String {
                        print("✅ Session created: \(sessionId)")
                        completion(sessionId)
                    } else {
                        completion(nil)
                    }
                } catch {
                    print("⚠️ Failed to parse response: \(error)")
                    completion(nil)
                }
            }.resume()
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript
    import AsyncStorage from '@react-native-async-storage/async-storage';

    export async function createAdmeshSession(): Promise<string | null> {
      try {
        const response = await fetch('https://api.useadmesh.com/agent/session/new', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        const sessionId = data.session_id;

        await AsyncStorage.setItem('admesh_session_id', sessionId);
        console.log('✅ Session created:', sessionId);
        return sessionId;
      } catch (error) {
        console.error('⚠️ Session creation failed:', error);
        return null;
      }
    }
    ```
  </Tab>
</Tabs>

### Response Format

```json
{
  "session_id": "admesh_sess_1760022990_w8RkKA",
  "created_at": "2024-10-20T10:30:00Z",
  "expires_at": "2024-10-20T11:30:00Z"
}
```

---

## Step 2: Get Recommendations

Once you have a valid session, call the `/agent/recommend` endpoint to fetch recommendations for the user's query.

<Tabs>
  <Tab title="TypeScript/JavaScript">
    ```typescript
    export async function getAdmeshRecommendations(query: string) {
      const ADMESH_BASE = "https://api.useadmesh.com";
      const sessionId =
        localStorage.getItem("admesh_session_id") || (await createAdmeshSession());

      const res = await fetch(`${ADMESH_BASE}/agent/recommend`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${process.env.REACT_APP_ADMESH_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ query, session_id: sessionId, format: "auto" }),
      });

      if (res.status === 401) {
        const newSession = await createAdmeshSession();
        return getAdmeshRecommendations(query);
      }

      return res.json();
    }
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    import { useState, useCallback } from 'react';

    export function useAdmeshRecommendations() {
      const [recommendations, setRecommendations] = useState(null);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const fetchRecommendations = useCallback(async (query: string) => {
        setLoading(true);
        setError(null);
        try {
          const sessionId = localStorage.getItem("admesh_session_id");
          if (!sessionId) throw new Error("No active session");

          const res = await fetch("https://api.useadmesh.com/agent/recommend", {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${process.env.REACT_APP_ADMESH_API_KEY}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ query, session_id: sessionId, format: "auto" }),
          });

          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

          const data = await res.json();
          setRecommendations(data);
          return data;
        } catch (err) {
          const message = err instanceof Error ? err.message : "Unknown error";
          setError(message);
          console.error("⚠️ Failed to fetch recommendations:", message);
          return null;
        } finally {
          setLoading(false);
        }
      }, []);

      return { recommendations, loading, error, fetchRecommendations };
    }
    ```
  </Tab>

  <Tab title="Android (Kotlin)">
    ```kotlin
    import kotlinx.coroutines.*
    import java.net.URL
    import java.net.HttpURLConnection
    import android.content.SharedPreferences

    class AdmeshRecommendationManager(private val prefs: SharedPreferences) {
        companion object {
            private const val ADMESH_BASE = "https://api.useadmesh.com"
            private const val API_KEY = "your_api_key_here"
        }

        suspend fun getRecommendations(query: String): String? = withContext(Dispatchers.IO) {
            try {
                val sessionId = prefs.getString("admesh_session_id", null) ?: return@withContext null

                val url = URL("$ADMESH_BASE/agent/recommend")
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Authorization", "Bearer $API_KEY")
                connection.setRequestProperty("Content-Type", "application/json")

                val body = """{"query":"$query","session_id":"$sessionId","format":"auto"}"""
                connection.outputStream.write(body.toByteArray())

                if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().readText()
                    android.util.Log.d("AdMesh", "✅ Recommendations fetched")
                    response
                } else {
                    android.util.Log.e("AdMesh", "⚠️ Failed: ${connection.responseCode}")
                    null
                }
            } catch (e: Exception) {
                android.util.Log.e("AdMesh", "⚠️ Error: ${e.message}")
                null
            }
        }
    }
    ```
  </Tab>

  <Tab title="Flutter (Dart)">
    ```dart
    import 'package:http/http.dart' as http;
    import 'package:shared_preferences/shared_preferences.dart';
    import 'dart:convert';

    class AdmeshRecommendationManager {
      static const String admeshBase = 'https://api.useadmesh.com';
      static const String apiKey = 'your_api_key_here';

      static Future<Map<String, dynamic>?> getRecommendations(String query) async {
        try {
          final prefs = await SharedPreferences.getInstance();
          final sessionId = prefs.getString('admesh_session_id');
          if (sessionId == null) return null;

          final response = await http.post(
            Uri.parse('$admeshBase/agent/recommend'),
            headers: {
              'Authorization': 'Bearer $apiKey',
              'Content-Type': 'application/json',
            },
            body: jsonEncode({
              'query': query,
              'session_id': sessionId,
              'format': 'auto',
            }),
          );

          if (response.statusCode == 200) {
            final data = jsonDecode(response.body);
            print('✅ Recommendations fetched');
            return data;
          } else {
            print('⚠️ Failed: ${response.statusCode}');
            return null;
          }
        } catch (e) {
          print('⚠️ Error: $e');
          return null;
        }
      }
    }
    ```
  </Tab>

  <Tab title="Swift/iOS">
    ```swift
    import Foundation

    class AdmeshRecommendationManager {
        static let admeshBase = "https://api.useadmesh.com"
        static let apiKey = "your_api_key_here"

        static func getRecommendations(query: String, completion: @escaping ([String: Any]?) -> Void) {
            guard let sessionId = UserDefaults.standard.string(forKey: "admesh_session_id") else {
                completion(nil)
                return
            }

            let url = URL(string: "\(admeshBase)/agent/recommend")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            let body: [String: Any] = [
                "query": query,
                "session_id": sessionId,
                "format": "auto"
            ]
            request.httpBody = try? JSONSerialization.data(withJSONObject: body)

            URLSession.shared.dataTask(with: request) { data, response, error in
                guard let data = data, error == nil else {
                    print("⚠️ Error: \(error?.localizedDescription ?? "Unknown")")
                    completion(nil)
                    return
                }

                do {
                    if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                        print("✅ Recommendations fetched")
                        completion(json)
                    } else {
                        completion(nil)
                    }
                } catch {
                    print("⚠️ Parse error: \(error)")
                    completion(nil)
                }
            }.resume()
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript
    import AsyncStorage from '@react-native-async-storage/async-storage';

    export async function getAdmeshRecommendations(query: string) {
      try {
        const sessionId = await AsyncStorage.getItem('admesh_session_id');
        if (!sessionId) throw new Error('No active session');

        const response = await fetch('https://api.useadmesh.com/agent/recommend', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${process.env.ADMESH_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            query,
            session_id: sessionId,
            format: 'auto',
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('✅ Recommendations fetched');
        return data;
      } catch (error) {
        console.error('⚠️ Error fetching recommendations:', error);
        return null;
      }
    }
    ```
  </Tab>
</Tabs>

### Example Response

```json
{
  "session_id": "admesh_sess_1760022990_w8RkKA",
  "placements": [
    {
      "id": "plc_01",
      "title": "Notion for Teams",
      "reason": "Recommended for collaboration",
      "ad_id": "ad_7a2b",
      "click_url": "https://api.useadmesh.com/click/r/ad_7a2b?...",
      "exposure_url": "https://api.useadmesh.com/expose/ad_7a2b?..."
    }
  ]
}
```

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | string | Yes | User's search or chat query |
| `session_id` | string | Yes | Session ID from `/agent/session/new` |
| `format` | string | No | Layout format: `auto`, `card`, `inline` |

---

## Step 3: Format Recommendations for LLM

After receiving AdMesh recommendations, pass them to your LLM or search API.
This lets your platform **blend sponsored recommendations** into organic responses.

<Tabs>
  <Tab title="TypeScript/JavaScript">
    ```typescript
    function formatRecommendationsForLLM(recommendations: any[], userQuery: string): string {
      const formattedRecs = recommendations
        .map((rec) => `- ${rec.title}: ${rec.click_url}`)
        .join('\n');

      return `
${userQuery}

=== WEAVE RECOMMENDATIONS (Integrate these naturally into your response) ===
Instructions: Mention these products/services naturally within your answer as relevant suggestions.
IMPORTANT: Always add '[Ad]' label as subscript after recommendation links to clearly mark them as sponsored content.
Format mentions as: [Product Name](link)<sub>[Ad]</sub>
Make recommendations feel organic. Use the exact links provided.

${formattedRecs}

INSTRUCTIONS FOR MENTIONING RECOMMENDATIONS:
1. Naturally weave the recommended products/services into your response.
2. Mention them where they fit contextually within your answer.
3. Use the exact links provided - preserve them exactly as given.
4. Format mentions as [Product Name](link)<sub>[Ad]</sub>.
5. Make them sound natural, not forced.
6. Mention 1–3 depending on relevance.
7. Keep all tracking links intact.
8. If you mention a product, include its link in the same sentence.
9. Every link must include the <sub>[Ad]</sub> subscript label for transparency.
`;
    }
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    import { useMemo } from 'react';

    export function useFormattedRecommendations(recommendations: any[], userQuery: string) {
      return useMemo(() => {
        if (!recommendations || recommendations.length === 0) return userQuery;

        const formattedRecs = recommendations
          .map((rec) => `- ${rec.title}: ${rec.click_url}`)
          .join('\n');

        return `
${userQuery}

=== WEAVE RECOMMENDATIONS (Integrate these naturally into your response) ===
Instructions: Mention these products/services naturally within your answer as relevant suggestions.
IMPORTANT: Always add '[Ad]' label as subscript after recommendation links to clearly mark them as sponsored content.
Format mentions as: [Product Name](link)<sub>[Ad]</sub>

${formattedRecs}

INSTRUCTIONS FOR MENTIONING RECOMMENDATIONS:
1. Naturally weave the recommended products/services into your response.
2. Mention them where they fit contextually within your answer.
3. Use the exact links provided - preserve them exactly as given.
4. Format mentions as [Product Name](link)<sub>[Ad]</sub>.
5. Make them sound natural, not forced.
6. Mention 1–3 depending on relevance.
7. Keep all tracking links intact.
`;
      }, [recommendations, userQuery]);
    }
    ```
  </Tab>

  <Tab title="Android (Kotlin)">
    ```kotlin
    class RecommendationFormatter {
        fun formatForLLM(recommendations: List<Map<String, String>>, userQuery: String): String {
            val formattedRecs = recommendations
                .map { rec -> "- ${rec["title"]}: ${rec["click_url"]}" }
                .joinToString("\n")

            return """
$userQuery

=== WEAVE RECOMMENDATIONS (Integrate these naturally into your response) ===
Instructions: Mention these products/services naturally within your answer as relevant suggestions.
IMPORTANT: Always add '[Ad]' label as subscript after recommendation links to clearly mark them as sponsored content.
Format mentions as: [Product Name](link)<sub>[Ad]</sub>
Make recommendations feel organic. Use the exact links provided.

$formattedRecs

INSTRUCTIONS FOR MENTIONING RECOMMENDATIONS:
1. Naturally weave the recommended products/services into your response.
2. Mention them where they fit contextually within your answer.
3. Use the exact links provided - preserve them exactly as given.
4. Format mentions as [Product Name](link)<sub>[Ad]</sub>.
5. Make them sound natural, not forced.
6. Mention 1–3 depending on relevance.
7. Keep all tracking links intact.
8. If you mention a product, include its link in the same sentence.
9. Every link must include the <sub>[Ad]</sub> subscript label for transparency.
            """.trimIndent()
        }
    }
    ```
  </Tab>

  <Tab title="Flutter (Dart)">
    ```dart
    class RecommendationFormatter {
      static String formatForLLM(
        List<Map<String, dynamic>> recommendations,
        String userQuery,
      ) {
        final formattedRecs = recommendations
            .map((rec) => '- ${rec['title']}: ${rec['click_url']}')
            .join('\n');

        return '''
$userQuery

=== WEAVE RECOMMENDATIONS (Integrate these naturally into your response) ===
Instructions: Mention these products/services naturally within your answer as relevant suggestions.
IMPORTANT: Always add '[Ad]' label as subscript after recommendation links to clearly mark them as sponsored content.
Format mentions as: [Product Name](link)<sub>[Ad]</sub>
Make recommendations feel organic. Use the exact links provided.

$formattedRecs

INSTRUCTIONS FOR MENTIONING RECOMMENDATIONS:
1. Naturally weave the recommended products/services into your response.
2. Mention them where they fit contextually within your answer.
3. Use the exact links provided - preserve them exactly as given.
4. Format mentions as [Product Name](link)<sub>[Ad]</sub>.
5. Make them sound natural, not forced.
6. Mention 1–3 depending on relevance.
7. Keep all tracking links intact.
8. If you mention a product, include its link in the same sentence.
9. Every link must include the <sub>[Ad]</sub> subscript label for transparency.
        ''';
      }
    }
    ```
  </Tab>

  <Tab title="Swift/iOS">
    ```swift
    class RecommendationFormatter {
        static func formatForLLM(
            recommendations: [[String: Any]],
            userQuery: String
        ) -> String {
            let formattedRecs = recommendations
                .compactMap { rec -> String? in
                    guard let title = rec["title"] as? String,
                          let url = rec["click_url"] as? String else {
                        return nil
                    }
                    return "- \(title): \(url)"
                }
                .joined(separator: "\n")

            return """
\(userQuery)

=== WEAVE RECOMMENDATIONS (Integrate these naturally into your response) ===
Instructions: Mention these products/services naturally within your answer as relevant suggestions.
IMPORTANT: Always add '[Ad]' label as subscript after recommendation links to clearly mark them as sponsored content.
Format mentions as: [Product Name](link)<sub>[Ad]</sub>
Make recommendations feel organic. Use the exact links provided.

\(formattedRecs)

INSTRUCTIONS FOR MENTIONING RECOMMENDATIONS:
1. Naturally weave the recommended products/services into your response.
2. Mention them where they fit contextually within your answer.
3. Use the exact links provided - preserve them exactly as given.
4. Format mentions as [Product Name](link)<sub>[Ad]</sub>.
5. Make them sound natural, not forced.
6. Mention 1–3 depending on relevance.
7. Keep all tracking links intact.
8. If you mention a product, include its link in the same sentence.
9. Every link must include the <sub>[Ad]</sub> subscript label for transparency.
            """
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript
    export function formatRecommendationsForLLM(
      recommendations: any[],
      userQuery: string
    ): string {
      const formattedRecs = recommendations
        .map((rec) => `- ${rec.title}: ${rec.click_url}`)
        .join('\n');

      return `
${userQuery}

=== WEAVE RECOMMENDATIONS (Integrate these naturally into your response) ===
Instructions: Mention these products/services naturally within your answer as relevant suggestions.
IMPORTANT: Always add '[Ad]' label as subscript after recommendation links to clearly mark them as sponsored content.
Format mentions as: [Product Name](link)<sub>[Ad]</sub>
Make recommendations feel organic. Use the exact links provided.

${formattedRecs}

INSTRUCTIONS FOR MENTIONING RECOMMENDATIONS:
1. Naturally weave the recommended products/services into your response.
2. Mention them where they fit contextually within your answer.
3. Use the exact links provided - preserve them exactly as given.
4. Format mentions as [Product Name](link)<sub>[Ad]</sub>.
5. Make them sound natural, not forced.
6. Mention 1–3 depending on relevance.
7. Keep all tracking links intact.
8. If you mention a product, include its link in the same sentence.
9. Every link must include the <sub>[Ad]</sub> subscript label for transparency.
`;
    }
    ```
  </Tab>
</Tabs>

### Example Output

> For workflow automation, you can try [ClickUp](https://api.useadmesh.com/click/r/ad_7a2b?...)<sub>[Ad]</sub> or [Notion](https://api.useadmesh.com/click/r/ad_9b1c?...)<sub>[Ad]</sub> for team documentation.

### Best Practices

✅ **DO:**
- Weave recommendations naturally into the response
- Use exact tracking links provided by AdMesh
- Always include `[Ad]` label for transparency
- Mention 1–3 products based on relevance
- Keep links intact with all parameters

❌ **DON'T:**
- Modify or shorten tracking URLs
- Hide the `[Ad]` label
- Force recommendations that don't fit
- Mention more than 3 products
- Break the link structure

---

## Step 4: Fire Exposure Pixels

After showing recommendations, platforms must **fire the exposure pixel** for each ad.
This tells AdMesh that the recommendation was displayed (a viewable impression).

### Setup Placeholder Anchor

Use a **placeholder anchor** to signal where AdMesh recommendations appear inside your organic response.
This does not render ads. It only gives us a stable element to watch for visibility and fire exposure pixels.

```html
<!-- Placeholder only. Do not render ads here. -->
<div id="admesh-recommendations" aria-hidden="true" style="width:0;height:0;overflow:hidden;"></div>
```

Place this anchor right before or right after you inject the LLM response that includes AdMesh links.

### Fire Exposure Pixels

Keep it simple: observe the placeholder. When it is visible, fire each unique `exposure_url` once.

```html
<script>
  // recommendations = array you received from /agent/recommend
  function fireExposureWhenAnchorVisible(recommendations) {
    const fired = new Set();
    const anchor = document.getElementById("admesh-recommendations");
    if (!anchor) return;

    const observer = new IntersectionObserver(([entry]) => {
      if (!entry.isIntersecting) return;

      recommendations.forEach((rec) => {
        if (fired.has(rec.ad_id)) return;
        fired.add(rec.ad_id);

        if (navigator.sendBeacon) {
          navigator.sendBeacon(rec.exposure_url);
        } else {
          fetch(rec.exposure_url, { method: "GET", keepalive: true, mode: "no-cors" });
        }
      });

      observer.disconnect();
    });

    observer.observe(anchor);
  }

  // Example usage after you inject the LLM response:
  // 1) Ensure the anchor exists in DOM
  // 2) Call the function with the placements you got from AdMesh
  // fireExposureWhenAnchorVisible(placements);
</script>
```

### Ensure Anchor Exists

Insert it right next to the LLM response with one line of JS, then run tracking.

```js
function ensureAdmeshAnchor(containerSelector = "#llm-output") {
  const container = document.querySelector(containerSelector);
  if (!container) return null;
  let anchor = document.getElementById("admesh-recommendations");
  if (!anchor) {
    anchor = document.createElement("div");
    anchor.id = "admesh-recommendations";
    anchor.setAttribute("aria-hidden", "true");
    anchor.style.cssText = "width:0;height:0;overflow:hidden;";
    container.insertAdjacentElement("afterend", anchor); // or "beforebegin"
  }
  return anchor;
}

// After you render the organic answer:
ensureAdmeshAnchor();
fireExposureWhenAnchorVisible(placements);
```

### Tracking Best Practices

- Keep your own UI. The placeholder is **only** for tracking.
- Keep the id exactly as provided: `admesh-recommendations`.
- Place the anchor right where the AdMesh mentions appear in the organic response, so visibility matches what users see.
- Fire each `exposure_url` once per `ad_id`.
- Use `sendBeacon` first, fetch as fallback.
- Do not modify `exposure_url` or any AdMesh links in the organic text.

---

## Step 5: Close Session (Optional)

When the user finishes their chat or conversion flow, close the AdMesh session.

<Tabs>
  <Tab title="TypeScript/JavaScript">
    ```typescript
    export async function closeAdmeshSession() {
      const sessionId = localStorage.getItem("admesh_session_id");
      if (!sessionId) return;

      try {
        const response = await fetch("https://api.useadmesh.com/agent/session/close", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ session_id: sessionId }),
        });

        if (response.ok) {
          const data = await response.json();
          console.log("✅ Session closed:", data);
          localStorage.removeItem("admesh_session_id");
        } else {
          console.error("❌ Failed to close session:", response.status);
        }
      } catch (error) {
        console.error("❌ Error closing session:", error);
        localStorage.removeItem("admesh_session_id");
      }
    }
    ```
  </Tab>

  <Tab title="React">
    ```typescript
    import { useCallback } from 'react';

    export function useAdmeshSessionClose() {
      const closeSession = useCallback(async () => {
        const sessionId = localStorage.getItem("admesh_session_id");
        if (!sessionId) return;

        try {
          const response = await fetch("https://api.useadmesh.com/agent/session/close", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ session_id: sessionId }),
          });

          if (response.ok) {
            const data = await response.json();
            console.log("✅ Session closed:", data);
            localStorage.removeItem("admesh_session_id");
            return data;
          } else {
            console.error("❌ Failed to close session:", response.status);
            return null;
          }
        } catch (error) {
          console.error("❌ Error closing session:", error);
          localStorage.removeItem("admesh_session_id");
          return null;
        }
      }, []);

      return { closeSession };
    }
    ```
  </Tab>

  <Tab title="Android (Kotlin)">
    ```kotlin
    import kotlinx.coroutines.*
    import android.content.SharedPreferences
    import java.net.URL
    import java.net.HttpURLConnection

    class AdmeshSessionCloser(private val prefs: SharedPreferences) {
        companion object {
            private const val ADMESH_BASE = "https://api.useadmesh.com"
        }

        suspend fun closeSession(): Boolean = withContext(Dispatchers.IO) {
            try {
                val sessionId = prefs.getString("admesh_session_id", null) ?: return@withContext false

                val url = URL("$ADMESH_BASE/agent/session/close")
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")

                val body = """{"session_id":"$sessionId"}"""
                connection.outputStream.write(body.toByteArray())

                val success = connection.responseCode == HttpURLConnection.HTTP_OK
                if (success) {
                    prefs.edit().remove("admesh_session_id").apply()
                    android.util.Log.d("AdMesh", "✅ Session closed")
                } else {
                    android.util.Log.e("AdMesh", "⚠️ Failed to close: ${connection.responseCode}")
                }
                success
            } catch (e: Exception) {
                android.util.Log.e("AdMesh", "⚠️ Error: ${e.message}")
                false
            }
        }
    }
    ```
  </Tab>

  <Tab title="Flutter (Dart)">
    ```dart
    import 'package:http/http.dart' as http;
    import 'package:shared_preferences/shared_preferences.dart';
    import 'dart:convert';

    class AdmeshSessionCloser {
      static const String admeshBase = 'https://api.useadmesh.com';

      static Future<bool> closeSession() async {
        try {
          final prefs = await SharedPreferences.getInstance();
          final sessionId = prefs.getString('admesh_session_id');
          if (sessionId == null) return false;

          final response = await http.post(
            Uri.parse('$admeshBase/agent/session/close'),
            headers: {'Content-Type': 'application/json'},
            body: jsonEncode({'session_id': sessionId}),
          );

          if (response.statusCode == 200) {
            await prefs.remove('admesh_session_id');
            print('✅ Session closed');
            return true;
          } else {
            print('⚠️ Failed to close: ${response.statusCode}');
            return false;
          }
        } catch (e) {
          print('⚠️ Error: $e');
          return false;
        }
      }
    }
    ```
  </Tab>

  <Tab title="Swift/iOS">
    ```swift
    import Foundation

    class AdmeshSessionCloser {
        static let admeshBase = "https://api.useadmesh.com"

        static func closeSession(completion: @escaping (Bool) -> Void) {
            guard let sessionId = UserDefaults.standard.string(forKey: "admesh_session_id") else {
                completion(false)
                return
            }

            let url = URL(string: "\(admeshBase)/agent/session/close")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            let body: [String: String] = ["session_id": sessionId]
            request.httpBody = try? JSONSerialization.data(withJSONObject: body)

            URLSession.shared.dataTask(with: request) { data, response, error in
                if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                    UserDefaults.standard.removeObject(forKey: "admesh_session_id")
                    print("✅ Session closed")
                    completion(true)
                } else {
                    print("⚠️ Failed to close session")
                    completion(false)
                }
            }.resume()
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ```typescript
    import AsyncStorage from '@react-native-async-storage/async-storage';

    export async function closeAdmeshSession(): Promise<boolean> {
      try {
        const sessionId = await AsyncStorage.getItem('admesh_session_id');
        if (!sessionId) return false;

        const response = await fetch('https://api.useadmesh.com/agent/session/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ session_id: sessionId }),
        });

        if (response.ok) {
          const data = await response.json();
          console.log('✅ Session closed:', data);
          await AsyncStorage.removeItem('admesh_session_id');
          return true;
        } else {
          console.error('❌ Failed to close session:', response.status);
          return false;
        }
      } catch (error) {
        console.error('❌ Error closing session:', error);
        await AsyncStorage.removeItem('admesh_session_id');
        return false;
      }
    }
    ```
  </Tab>
</Tabs>

### When to Close

- User closes chat or tab
- Conversion completes
- Platform resets context
- User logs out

---

## Complete Integration Example

Here's a complete end-to-end example in TypeScript:

```typescript
// 1. Create session
const sessionId = await createAdmeshSession();

// 2. Get recommendations
const { placements } = await getAdmeshRecommendations("best project management tools");

// 3. Format for LLM
const prompt = formatRecommendationsForLLM(placements, "best project management tools");

// 4. Call LLM
const llmResponse = await callLLM(prompt);

// 5. Render response with anchor
renderResponse(llmResponse);
ensureAdmeshAnchor("#response-container");

// 6. Fire exposure pixels
fireExposureWhenAnchorVisible(placements);

// 7. Close session when done
await closeAdmeshSession();
```

---

## Summary

✅ **Integration complete!** You now have a fully functional Weave Ad Format integration.

Your platform can now:
- Create sessions for conversation context
- Fetch contextual recommendations
- Format recommendations for your LLM
- Blend sponsored content naturally into responses
- Track exposures with exposure pixels
- Close sessions cleanly

---

## Next Steps

- [Tail & Product Format](/platforms/tail-format) - For SDK-based automatic rendering
- [FAQ](/platforms/faq) - Common questions and troubleshooting

